import 'dart:async';

import 'package:build/build.dart';
import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';

import 'http_parse.dart';
import 'json_parse_model_base.dart';
import 'logging.dart';
import 'source_parse.dart';

JLogger jlogger = JLogger(true);

class Json2ModelPrintBuilder implements Builder {
  final BuilderOptions options;
  Json2ModelPrintBuilder({
    required this.options,
  });

  @override
  FutureOr<void> build(BuildStep buildStep) async {
    try {
      // logger.info('options=${options.config}');
      jlogger.info('options=${options.config}');
      final inputId = buildStep.inputId;
      var contents = await buildStep.readAsString(inputId);
      final sourceConfig = SourceParse.instance.parse(contents);

      final lib = Library((b) => b
        ..directives.add(Directive.import('package:flutter/foundation.dart')));
      final importCode = lib.accept(DartEmitter());
      List<String> resultCodes = ['$importCode'];

      var outputId = AssetId(inputId.package, sourceConfig.outpath);

      var jsonMap = sourceConfig.source ??
          await HttpParse.instance.get(
            sourceConfig.api,
            host: options.config['host'],
            token: options.config['token'],
          );
      if (jsonMap == null) {
        jlogger.info('$tag jsonMap is null');
        return;
      }

      if (jsonMap.isNotEmpty) {
        final data = jsonMap['data'];
        if (data is bool || data is String || data is int) {
          jlogger.info('$tag is bool or string or int');
        } else if (data is List) {
          if (data.first is Map<String, dynamic>) {
            _buildClassCode(
              className: sourceConfig.className,
              source: data.first,
              resultCodes: resultCodes,
            );
          } else {
            jlogger.info('$tag is Map<bool> or Map<String> or Map<bool>');
          }
        } else if (data is Map<String, dynamic>) {
          _buildClassCode(
            className: sourceConfig.className,
            source: data,
            resultCodes: resultCodes,
          );
        }
        final listCodes = resultCodes.join("\n");
        final finalResult = DartFormatter().format(listCodes);
        await buildStep.writeAsString(outputId,
            '// Generated by build_runner, don\'t modify it.\n$finalResult');
      } else {
        jlogger.info(
            'please check your assets/json/xxx.json file exist or formatter!');
      }
    } catch (e, s) {
      jlogger.error('error $e $s');
    }
  }

  @override
  Map<String, List<String>> get buildExtensions => {
        '^assets/json/{{}}.json': ["lib/json2model_gen/{{}}.dart"]
      };
}

void _buildClassCode({
  required String className,
  required Map<String, dynamic> source,
  required List<String> resultCodes,
}) {
  final emitter = DartEmitter(orderDirectives: true);

  /// 1. add fileds
  final fields = _buildClassFields(
    source: source,
    resultCodes: resultCodes,
  );

  /// 2. add constructor
  List<Constructor> constructors = [];

  //// 2.1 add constructor fields
  final constructorFields = _buildConstructorFields(fields);
  constructors.add(constructorFields);

  /// 2.2 add fromJson constructor method
  final fromJsonConstructor = _buildFromJsonConstructor(fields, className);
  constructors.add(fromJsonConstructor);

  /// 3 add toJson method
  final toJsonMethod = _buildToJsonMethod(fields);

  /// 4 generate a Class
  final model = Class(
    (b) => b
      ..name = className
      ..fields.addAll(fields)
      ..constructors.addAll(constructors)
      ..methods.add(toJsonMethod),
  );
  final code = DartFormatter().format('${model.accept(emitter)}');
  resultCodes.add(code);

  /// 5 generate a extension Class
  final extensionCode = Extension(
    (b) => b
      ..name = '${className}Ext'
      ..on = TypeReference((b) => b.symbol = className)
      ..methods.add(
        Method(
          (b) => b
            ..name = 'fromJson'
            ..returns = refer(className)
            ..static = true
            ..lambda = true
            ..requiredParameters.add(Parameter((b) => b..name = "e"))
            ..body = Code('$className.fromJson(e)'),
        ),
      )
      ..methods.add(
        Method(
          (b) => b
            ..name = 'fromCompute'
            ..returns = TypeReference(
              (b) => b
                ..symbol = 'Future'
                ..types.add(refer(className)),
            )
            ..static = true
            ..lambda = true
            ..requiredParameters.add(Parameter((b) => b..name = "e"))
            ..body = Code('compute(fromJson, e)'),
        ),
      ),
  );
  final extensionFormatterCode =
      DartFormatter().format('${extensionCode.accept(emitter)}');
  resultCodes.add(extensionFormatterCode);
}

/// 1. add fileds
List<Field> _buildClassFields({
  required Map<String, dynamic> source,
  required List<String> resultCodes,
}) {
  List<Field> fields = [];
  for (final item in source.entries) {
    if (item.value is Map) {
      _buildClassCode(
        className: item.key.capitalize,
        source: item.value,
        resultCodes: resultCodes,
      );
      fields.add(Field(
        (b) => b
          ..name = item.key
          ..modifier = FieldModifier.final$
          ..type = refer('${item.key.capitalize}?'),
      ));
    } else {
      fields.add(Field(
        (b) => b
          ..name = item.key
          ..modifier = FieldModifier.final$
          ..type = refer(
            _buildFieldType(
              item: item,
              resultCodes: resultCodes,
            ),
          ),
      ));
    }
  }
  return fields;
}

String _buildFieldType({
  required MapEntry<String, dynamic> item,
  required List<String> resultCodes,
}) {
  dynamic value = item.value;
  final runtimeType = value.runtimeType;
  if (runtimeType != List) {
    if (runtimeType == Null) {
      return 'dynamic';
    } else if (runtimeType == String) {
      try {
        if (RegExp(r'^[\d]+$').hasMatch(value)) {
          return "String";
        }
        DateTime.parse(value);
        return "DateTime?";
      } catch (e) {
        return "String";
      }
    }
    return '$runtimeType';
  }
  if ((value as List).isEmpty) {
    return '$runtimeType';
  }
  final firstValueRuntimeType = value.first.runtimeType;
  if ('$firstValueRuntimeType' == "_Map<String, dynamic>") {
    if (value.first == {}) {
      return 'List<dynamic>';
    }
    _buildClassCode(
      className: item.key.capitalize,
      source: value.first,
      resultCodes: resultCodes,
    );
    return 'List<${item.key.capitalize}>';
  } else if (firstValueRuntimeType == String) {
    return 'List<String>';
  } else if (firstValueRuntimeType == int) {
    return 'List<int>';
  } else if (firstValueRuntimeType == bool) {
    return 'List<bool>';
  } else if (firstValueRuntimeType == double) {
    return 'List<double>';
  }
  return 'dynamic';
}

/// 3 add toJson method
Method _buildToJsonMethod(List<Field> fields) {
  final toJsonMethodBody = StringBuffer('');
  for (final e in fields) {
    toJsonMethodBody.writeln(toMapTypeMaping(
      typeKey: e.type!.symbol!,
      fieldName: e.name,
    ));
  }
  final toJsonMethod = Method(
    (b) => b
      ..name = "toJson"
      ..lambda = true
      ..returns = TypeReference((b) => b
        ..symbol = 'Map'
        ..types.addAll([
          refer('String'),
          refer('dynamic'),
        ]))
      ..body = Code('''{${toJsonMethodBody.toString()}}'''),
  );
  return toJsonMethod;
}

/// 2.2 add fromJson constructor method
Constructor _buildFromJsonConstructor(List<Field> fields, String className) {
  final fromJsonBody = StringBuffer();
  for (var e in fields) {
    fromJsonBody.writeln(toJsonTypeMapping(
      typeKey: e.type!.symbol!,
      fieldName: e.name,
    ));
  }

  final fromJsonConstructor = Constructor(
    (b) => b
      ..name = 'fromJson'
      ..requiredParameters.add(Parameter(
        (b) => b
          ..name = 'json'
          ..type = TypeReference((b) => b
            ..symbol = 'Map'
            ..types.addAll([
              refer('String'),
              refer('dynamic'),
            ])),
      ))
      ..lambda = true
      ..body = Code('''$className(${fromJsonBody.toString()})''')
      ..factory = true,
  );
  return fromJsonConstructor;
}

//// 2.1 add constructor fields
Constructor _buildConstructorFields(List<Field> fields) {
  // fields.any((element) => element.type!.symbol!.contains('?'))
  final constructorFields = Constructor((b) => b
    ..constant = true
    ..optionalParameters.addAll(fields.map((e) => Parameter(
          (b) => b
            ..name = e.name
            ..named = true
            ..toThis = true
            ..required = e.type!.symbol!.contains('?') == false,
        ))));
  return constructorFields;
}

String toJsonTypeMapping({
  required String typeKey,
  required String fieldName,
}) {
  if (typeKey == "int") {
    return "$fieldName: json['$fieldName'] as int? ?? 0,";
  } else if (typeKey == "String") {
    return "$fieldName: json['$fieldName'] as String? ?? \"\",";
  } else if (typeKey == "bool") {
    return "$fieldName: json['$fieldName'] as bool? ?? false,";
  } else if (typeKey == "double") {
    return "$fieldName: json['$fieldName'] as double? ?? 0.0,";
  } else if (typeKey == "DateTime?") {
    return "$fieldName: json['$fieldName'] == null ? null : DateTime.tryParse(json['$fieldName'])?.toLocal(),";
  } else if (typeKey == "List<String>" ||
      typeKey == "List<bool>" ||
      typeKey == "List<int>" ||
      typeKey == "List<double>") {
    return "$fieldName: json['$fieldName'] ==null ? []: $typeKey.from(json['$fieldName']),";
  } else if (typeKey == "List<dynamic>") {
    return "$fieldName: json['$fieldName'] ==null ? []: $typeKey.from(json['$fieldName']),";
  } else if (typeKey == "dynamic") {
    return "$fieldName: json['$fieldName'],";
  } else if (typeKey == "List<${fieldName.capitalize}>") {
    return "$fieldName: json['$fieldName'] == null ? [] : List.castFrom(json['$fieldName']).map((e) => ${fieldName.capitalize}.fromJson(e)).toList(),";
  }
  return '$fieldName: json["$fieldName"] == null ? null : $typeKey.fromJson(json["$fieldName"]),';
}

String toMapTypeMaping({
  required String typeKey,
  required String fieldName,
}) {
  if (typeKey == fieldName.capitalize) {
    return "'$fieldName': ${fieldName.capitalize}.toJson(),";
  } else if (typeKey == "List<${fieldName.capitalize}>") {
    return "'$fieldName': $fieldName.map((e)=>e.toJson).toList(),";
  } else if (typeKey == "DateTime?") {
    return "'$fieldName': $fieldName?.toIso8601String(),";
  }
  return "'$fieldName': $fieldName,";
}
